---
title: "Applications of Analytics in NHL Goaltender Evaluation"
author: "GUO"
date: "April 30, 2016"
output: html_document
---
###BIO260/CSCI107 FINAL PROJECT

#The Project in Three Sentences
The purpose of this project is to assist NHL pro scouts in identifying goalies who are undervalued because they play on a bad team. Play-by-play data is collected from all 1230 games played this season to adjust for shot distance, shot type, power play, the shooter, and the team effects. The data is then analyzed using a multivariate regression model that outputs a final ranking of goalies.

The application of this work is immediate in the NHL playoffs that's currently underway. We can use analytics to help teams determine which goalies should start in goal. The recommendations from this analysis would have helped all three teams who have played more than one goaltender in this playoff series.

Note: Due to the time it takes for data-scraping (roughly 10 hours), it is recommended to load the .RData files. The final dataset used in the analysis can be found here in .csv format: https://github.com/piperwolli/FinalProject_HockeyAnalytics/blob/master/nhl_shots_2016.csv

#Background and Motivation
The National Hockey League is evolving. The league introduced a hard salary cap in 2005. This effectively took away the advantage of financially resourceful franchises to attract the top players with large contracts. In 2005, the inaugural year of the cap system, each team was allowed to spend maximum $39 million with no more than 20% paid out to a single player. It's been a decade since the cap was introduced, yet most teams are still struggling with optimizing a competitive roster.

Under the cap system, it has never been more important to draft well and find value in free agents. Teams who do not manage their cap space end up "buying out" the bad contracts they signed. Bad contracts not only cost teams financially but also in valuable cap space. The Tampa Bay Lightning, for example, bought out Vincent Lecavalier (F) for $32Million dollars. New York Islanders are playing paying Rick DiPietro (G) $1.5M annually for 16 years.
http://www.sportsnet.ca/hockey/nhl/countdown-to-nhl-buyout-season-what-we-know/

#The Goalies Market
The best teams in the "new era" of NHL are the teams who can optimize their contracts based on finaces - but that is misleading at best. The underlying factor behind a sound cap management system is actually a solid player evaluation system. 

One of the most interesting component of hockey is in goaltending - no playoff teams could expect a long run at the Stanley Cup without at least "okay" goaltending. As a bit of an overview, each team has up to three goaltenders, usually one starting goalie and two back-ups. Starting goaltenders in the league typically play 50 to 60 of the 82 games in a season, and the back-ups share the net in the remaining games. Large competitive franchise typically spends north of $5M on its starting goaltender. Back-ups earn anywhere from under $1M to $5M: http://www.spotrac.com/nhl/rankings/average/goaltender/

Because the salary cap system punishes team with underperforming players, teams have to be critical in allocating the cap space for offense and defense - including goalkeeping. Compare New York Rangers with the Anaheim Ducks who won equal number of games this season: NYR dedicated $9.25M in goaltenders and ranked 15th in goals against per game this season, the ANA ranks 1st in the league but only spent less than a third of budget! Having cost-efficient goaltending allows the team to spend to upgrade offensive capabilities. 

#The Approach

Unlike baseball where the team performance is more-or-less an aggregate of individual player performances, hockey is a more dynamic sport. Goaltending, however, is an area where an individual can make a large impact. This gives analytics the potential to change the game.
Traditional goalie statistics consist of number of wins, save percentage, and goals against average. There are some intuitive reasons why these basic stats are not sufficient: 

1.	The Shots
Goalies face different types of shots, coming from different distances

2.	The Situation on Ice
Teams who take more penalties force their goalies to spend more time at a disadvantage. Making a save during penalty kill should be looked at differently compared to save made playing at even strength

3.	The Team
Some teams play a defensive game whereas others are more offensive-minded. A good goalie could play for a bad team and end up with poor stats (See Devan Dubnyk story: http://edmontonjournal.com/sports/hockey/nhl/goalie-devan-dubnyk-turns-page-on-struggles-from-a-different-lifetime )

4.	Players
Stopping a breakaway from a dangler (Crosby) or gloving a shot from a top sniper (Ovechkin) is different from stopping a shot from the blue line by a third pair defenseman.

There are also other factors in play, such as the stadium, the calendar effect, home ice advantage, that could also influence a goalie's performance. Data mining from the play-by-play data allow us to adjust for these factors. However, in this project, we run into the issue of over-fitting when we run too many of these scenarios.

Mathematically:

$$Prob(Goal) = \sum\left( f_{log}(Distance, ShotType, Position) * \frac{N_{goals}}{N_{shots} - N_{misses}} + PP_e + Team_t + Opp_o + Player_i + \epsilon_0\right)$$

$$E[GoalsAllowed] = \sum_{i=1}^{p}\left(P(Goals)_p\right)$$

#Data Scraping
This is 50% of the work. The NHL keeps a record of all play-by-play data for each game on its website. Game 0001 of the season played between the Toronto Maple Leafs and the Montreal Canadiens is found in a table here: http://www.nhl.com/scores/htmlreports/20152016/PL020001.HTM

This block of code below scrapes the data we need for this analysis. The data is already in tabular form, so we used XML to capture the information. The data, however, is extremely messy as there are hundres of "hidden tables" built into the web page. More explanations can be found in the comments within the code.

Note: it takes roughly 10 hours to execute this script, that's why "eval" is set to FALSE in this RMarkdown File.


```{r message=FALSE, warning=FALSE, eval=FALSE}
library(XML)
library(dplyr)
library(tidyr)

############## The link to get the data

gamelink <- paste("http://www.nhl.com/scores/htmlreports/20152016/PL0",gamenum,".HTM", sep="") 
## We are getting the 2015-2016 data

gamenum <- c(20001:21230)                                                                      
## There are 1230 regular season games played each season

MasterPBP <- c()
## Create empty list to store future data

gameid <- 0
## Starting at game 1

for (n in gamelink){
  gameid <- gameid + 1
  print(paste(n,Sys.time())) ## Keeps track of where we are in the process of data scraping (1230 = finish)
  gamedata_p <- readHTMLTable(n,stringsAsFactors=F, as.data.frame=TRUE)
  
  tabs <- c()
  
  ## There are hidden tables, so we are only interested in tables that are of certain size
  for (i in 1:length(gamedata_p)){ 
    size <- nrow(gamedata_p[[i]])
    
    if (!is.null(size)){
      if(size > 30){
        tabs <- rbind(tabs,i)
      }
    }
  }

  gamedata <- c()
  for (p in tabs){
    gamedata<-rbind(gamedata,gamedata_p[[p]] %>% select(1:8))
  }
  
  ## There are exceptions on a few pages, after clearing all the exception cases, these are the final conditions needed
  g <- gamedata %>% filter(!is.na(V6) & V6!="" & V1 != "#") %>% 
                    mutate(GameID = gameid) %>%
                    select(GameID, 1:8)
  
  MasterPBP <- rbind(MasterPBP, g)
  
  ###### Free up some memory
  rm(g)
  rm(tabs)
  rm(gamedata)
  rm(gamedata_p)
  
  #save(MasterPBP, file="MasterPBP2016.RData") 
  ## save the r object to file as it scrapes data, this is a good idea in case R crashes
}

```

Instead of spending 10 hours scraping data, you can load the data directly here: MasterPBP2016.RData
(https://github.com/piperwolli/FinalProject_HockeyAnalytics/blob/master/MasterPBP2016.RData)

The play-by-play data contains every event in the game. We can wrangle this data to identify the type of shot, the distance, and other situational information relating to the game. However, before we can do that, we need to identify the Shooter and the Goalie in every shot. Unfortunately the play-by-play data only gives us players' and goalies' jersey number. So we have to look up the players' names in order to properly identify players. Since players may change their jersey number, be traded, acquired, or promoted from the minor leagues, we don't have a straightforward way of doing this. We need to obtain a database that has the roster information for each game. 

Luckily the NHL keeps track of this information, the table for Game 0001 roster can be found here: http://www.nhl.com/scores/htmlreports/20152016/RO020001.HTM

We run the following block of code to scrape this data. It's slightly more complicated than the code used earlier, but there are lot of similarities. It takes about 20~30 minutes to run.


```{r message=FALSE, warning=FALSE, eval=FALSE}
library(XML)
library(dplyr)
library(tidyr)

gamenum <- c(20001:21230)
gamelink <- paste("http://www.nhl.com/scores/htmlreports/20152016/RO0",gamenum,".HTM", sep="")

?data.frame
master_scores <- data.frame()
master_roster <- data.frame()
gn <- 0

for (n in gamelink){
  gn <- gn + 1
  print(paste(n, Sys.time()))
  gamedata_p <- readHTMLTable(n, stringsAsFactors=F, as.data.frame=TRUE)
  
  scores <- c(gamedata_p[[2]][20,1],gamedata_p[[2]][3,1],gamedata_p[[2]][20,2],gamedata_p[[2]][15,1])
  setting <- c(gamedata_p[[2]][9:12,1])
  
  GameID <- as.integer(substr(setting[4], 6, 9))
  Visitor <- scores[1]
  VS <- scores[2]
  Home <- scores[3]
  HS <- scores[4]
  WinningTeam <- ifelse(HS>VS,Home,Visitor)
  Date <- setting[1]
  Arena <- substr(setting[2], regexpr("at", setting[2])+3, 99)
  Attendance <- substr(setting[2], 12,regexpr("at", setting[2])-2)
  Time <- setting[3]
  
  master_scores <- rbind(master_scores,  c(GameID,Visitor,VS,Home,HS,WinningTeam,Date,Arena,Attendance,Time))
  
  VR <- gamedata_p[[11]] %>% mutate(Side = "Visitor") %>% 
                             mutate(Team = Visitor) %>% mutate(GameID = gn)
  HR <- gamedata_p[[12]] %>% mutate(Side = "Home") %>% 
                             mutate(Team = Home) %>% mutate(GameID = gn)
  
  master_roster <- rbind(master_roster, VR)
  master_roster <- rbind(master_roster, HR)
  
}

master_roster <- master_roster %>% select(GameID,Team,Side, 1:3)
names(master_roster) <- c("GameID","Team","Side","Num","Pos","Player")

#save(master_roster, file="MasterRoster2016.RData") ## save the r object to file

```

Again, this file can be loaded here: MasterRoster2016.RData
(https://github.com/piperwolli/FinalProject_HockeyAnalytics/blob/master/MasterRoster2016.RData)

#Data Wrangling
The raw data we collected earlier isn't very insightful. Although it has all the information, it's not organized in a manner for us to perform analytics. Here is what play-by-play data looks like.

```{r message=FALSE, warning=FALSE, warning=FALSE, echo=FALSE}
import <- function(f)        ## This function allows R to load the objects we saved earlier
{
  env <- new.env()
  nm <- load(f, env)[1]
  return(env[[nm]])
}
setwd("C:\\Users\\WhiteWhale\\Dropbox\\CSCI-107\\Hockey Project\\FinalProject_HockeyAnalytics")
MasterPBP <- import("MasterPBP2016.RData")

MasterPBP <- head(MasterPBP)
MasterPBP$V7 <- gsub("[\n\r]", "", MasterPBP$V7)
MasterPBP$V8 <- gsub("[\n\r]", "", MasterPBP$V8)

```

```{r message=FALSE, warning=FALSE}

### Sample Data ###
MasterPBP 

```

We are still far away from the end goal as the raw data needs lots of work. The columns are not labelled intuitively, the event description is also not structured in a way for the computer to under.
But before we get into data cleaning, let's take a step back and look at what we are trying to accomplish so we know how we should structure the data. The objective is to create a table with information on which player took the shot, which team does that player play for, when did he take the show (what period), what type of shot was it, how far was he away from the net, who's the opposing goalie, and what's the opposing team.

So first, we need to extract information in column V6. Second, we need to identify the goalie based on the line-up in V7 and V8. Finally, we need to blend the play-by-play data with roster data that we collected.

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(knitr)

import <- function(f)        ## This function allows R to load the objects we saved earlier
{
  env <- new.env()
  nm <- load(f, env)[1]
  return(env[[nm]])
}

## To save time, we import the R objects scraped earlier
pbp <- import("MasterPBP2016.RData")    
ro <- import("MasterRoster2016.RData") 

############### CLEAN UP #####################

clean_pbp <- function(pbp){
  shots <- pbp %>% filter(V5=="SHOT" | V5 == "GOAL" | V5 == "MISS" | V5== "BLOCK") %>% filter(V2 <= 3)
  shots$V7 <- gsub("[\n\r]", "", shots$V7)
  shots$V7 <- gsub("[[:blank:]]", ",", shots$V7)
  shots$V8 <- gsub("[\n\r]", "", shots$V8)
  shots$V8 <- gsub("[[:blank:]]", ",", shots$V8)
  shots <- separate(data = shots, col = V6, into = c("Team","Player","TMP"), fill="right", sep = "#", extra = "merge") %>% select(-TMP)
  shots <- separate(data = shots, col = Player, into = c("Player","ShotType","TMP"), fill="right", sep = "," , extra = "merge")
  shots <- separate(data = shots, col = TMP, into = c("TMP","Dist"), fill="right", sep = "," , extra = "merge") %>% select(-TMP)
  shots <- separate(data = shots, col = Dist, into = c("TMP","Dist"), fill="left", sep = "," , extra = "merge") %>% select(-TMP)
  shots <- separate(data = shots, col = Dist, into = c("Dist","TMP"), fill="left", sep = "ft" , extra = "merge") %>% select(-TMP)
  shots <- separate(data = shots, col = Team, into = c("Team","TMP"), fill="left", sep = " ", extra = "merge") %>% select(-TMP)
  shots <- separate(data = shots, col = Player, into = c("Player","TMP"), fill="left", extra = "merge") %>% select(-TMP)
  return(shots)
}

pbp <- clean_pbp(pbp)
names(pbp) <- c("GameID","n","Prd","PP","Time","Event","Team","Player","ShotType","Dist","LineV","LineH")

```

Now the master play-by-play data looks much cleaner. We are able to get the critical information we need. There are three more things we need to do, however. First, team names in the play-by-play and the roster database are of different form. For example, one database uses "TORONTO MAPLE LEAFS", other has the short-coded version "TOR". We have to convert the formats to keep the naming consistent. Second, we need to categorize each player's position. Center (C), Left Wing (L) and Right Wing (R) are all forward position and the defensemen are grouped together (D). Lastly, we need to identify which goaltender was on the receiving end of the shot. Since the database contains the full line-up for both teams, identifying the goalie isn't so straight forward. We will have to use home/visiting teams information to identify the goaltender.

```{r message=FALSE, warning=FALSE}
################ GET TEAM LIST ###############

teams <- c()
teams <- cbind(teams, sort(as.vector(unique(pbp$Team))))
teams <- cbind(teams, sort(as.vector(unique(ro$Team))))
teams <- data.frame(teams)
names(teams) <- c("tm","Team")

teams$Team[5] <- "CAROLINA HURRICANES"
teams$Team[6] <- "COLUMBUS BLUE JACKETS"
teams$Team[7] <- "CALGARY FLAMES"
teams$Team[8] <- "CHICAGO BLACKHAWKS"
teams$Team[9] <- "COLORADO AVALANCHE"
teams$Team[18] <- "NASHVILLE PREDATORS"
teams$Team[17] <- "NEW JERSEY DEVILS"
teams$Team[30] <- "WASHINGTON CAPITALS"
teams$Team[29] <- "WINNIPEG JETS"

ro <- left_join(ro, teams)
ro$Player <- gsub("\\s*\\([^\\)]+\\)","", as.character(ro$Player))


############### GET PLAYER AND POSITION FOR EACH GAME #########################
ro_pos <- function(m){
  Pos <- ro %>% select(Player, Pos)
  Pos$Player <- gsub("\\s*\\([^\\)]+\\)","", as.character(Pos$Player))
  Pos <- unique(Pos)
  Pos <- Pos %>% mutate(Pos2 = ifelse(Pos=="D","D","F"))
  names(Pos)[1] <- "Shooter"
  return(Pos)
}

pos <- ro_pos(ro)

getOpp <- function(g, t){
  opp <- tr %>% filter(GameID == g, tm != t) %>% .$tm
  return(opp)
}

pbp <- left_join(pbp, ro %>% select(GameID, tm, Side) %>% 
                             mutate(Team = tm) %>% 
                             unique() %>% 
                             select(GameID, Team, Side), 
                             by = c("GameID","Team"))

tr <- ro %>% select(GameID, tm) %>% unique
tr <- tr %>% mutate(Opp = mapply(getOpp, GameID, tm))
names(tr) <- c("GameID","Team","Opp")

pr <- ro %>% select(GameID, Num, tm, Player) %>% unique
names(pr) <- c("GameID","Player","Team","Shooter")

gr <- ro %>% filter(Pos == "G") %>% select(GameID,tm, Num, Player) %>% unique()
names(gr) <- c("GameID","Opp","GoalieNum","Goalie")

pbp <- left_join(pbp, tr %>% select(GameID, Team,Opp), by =c("GameID","Team"))
pbp <- left_join(pbp, pr %>% select(GameID, Player, Team, Shooter), by =c("GameID","Team", "Player"))

############### GET GOALIE ################

getGoalie <- function(line){
  s <- tail(gregexpr(",",line)[[1]],1)+1
  e <- gregexpr("G",line)[[1]][1]-1
  substr(line, s, e)
}

## The idea is to find the jersey number with "G" (for goalie) in the line-up information and pull it from the column (either LineV or LineH)

shots <- pbp %>% select(GameID,Prd,PP,Event,Team,Side,Shooter,ShotType,Dist,LineV,LineH,Opp)
shots <- shots %>% mutate(GoalieNum = as.character(ifelse(Side == "Home", lapply(LineV, getGoalie), lapply(LineH, getGoalie))))
shots <- left_join(shots, gr, by=c("GameID","Opp", "GoalieNum"))
shots <- shots %>% select(-LineV,-LineH,-GoalieNum)
shots <- left_join(shots, pos %>% select(-Pos))
shots <- shots %>% filter(!is.na(Dist))
shots$Goalie[is.na(shots$Goalie)] <- "EMPTY"
shots$Dist <- gsub("Off. Zone, ","", as.character(shots$Dist))
shots$Dist <- gsub("Def. Zone, ","", as.character(shots$Dist))
shots$Dist <- as.numeric(shots$Dist)


# save(shots, file="Shots2016.RData") ## This object can be saved to reduce run-time

```

And this is what the data looks like after cleaning:

```{r message=FALSE, warning=FALSE}
head(shots)

```

#Data Exploration
We can find some very interesting results from exploring and visualizing the data. We can look in different ways on how many shots were attempted (Shots), how many missed (Misses), how many went it (Goals), shot accuracy (A), and of those that hit the net, the goal probability (GP).

```{r message=FALSE, warning=FALSE}
mlshots <- shots %>% mutate(Res = ifelse(Event=="GOAL",1,0))
mlshots <- mlshots %>% mutate(EN = ifelse(Goalie=="EMPY",1,0))

mlshots %>% group_by(ShotType) %>% 
            summarize(Shots = n(), 
                      Misses = sum(Event=="MISS"), 
                      Goals = sum(Res), 
                      A = (Shots-Misses)/Shots,
                      GP = Goals/(Shots-Misses))

```

Penalty shots have the highest probability of hitting on-target, and the highest probability of scoring. Slapshots and wrap-arounds are the least effective in today's NHL. Deflection and Tip_in have high probability of scoring, but they are less likely to be on target.

Separating forwards(F) from defensemen(D), we can get a quick summary of how the two positions are different when it comes to shooting accuracy and probability of scoring. 

```{r message=FALSE, warning=FALSE}
mlshots %>% group_by(Pos2) %>% 
            summarize(Shots = n(), 
                      Misses = sum(Event=="MISS"), 
                      Goals = sum(Res), 
                      A = (Shots-Misses)/Shots, 
                      GP = Goals/(Shots-Misses))
```

As expected, it is much more difficult for a defense man to score compared to a forward. (As a side note: Teams may want to scout their opponents by looking at the ratio of shots taken by defense vs forward. This will help the team in its defensive zone coverage.)

These two tables below summarize the how period and power play affect scoring:

```{r message=FALSE, warning=FALSE}

## Segment by period ###
mlshots %>% group_by(Prd) %>% 
  summarize(Shots = n(), 
            Misses = sum(Event=="MISS"), 
            Goals = sum(Res), 
            A = (Shots-Misses)/Shots, 
            GP = Goals/(Shots-Misses))

## Segment by Power Play ##
mlshots %>% group_by(PP) %>% 
            summarize(Shots = n(), 
                      Misses = sum(Event=="MISS"), 
                      Goals = sum(Res), 
                      A = (Shots-Misses)/Shots, 
                      GP = Goals/(Shots-Misses))

```
2nd period appears to be the busiest in terms of shots. There's also a higher probability of scoring in the 3rd period. Unsurprisingly, power-play goals, which account for roughly 20% of all goals, has a higher probability of scoring.

We can also look at whether homeice advantage is truly an advantage.
```{r message=FALSE, warning=FALSE}
## Segment by Home vs. Visitors ##
mlshots %>% group_by(Side) %>% 
            summarize(Shots = n(), 
                      Misses = sum(Event=="MISS"), 
                      Goals = sum(Res), 
                      A = (Shots-Misses)/Shots, 
                      GP = Goals/(Shots-Misses))
```
Separating goal information by home team versus visiting team, it does appear the home team has a slight advantage. There are more goals and shot attemps by the home team. There is also a higher probability of scoring for the home team.


We can visualize the data to do some comparative analyses of the teams and players. Analyzing the shot accuracy and scoring probability of teams, we can identify the teams that play a dominant possession game. Looking at the visual below, we can conclude that the Toronto Maple Leafs, who is in last place this season, is one of the top offensive teams in terms of shots attempted. The data shows TOR plays a great system that generates offense opportunities. However, the team lacks the skill to score overall.

Of the top 10, Toronto and Boston are the ONLY teams who missed the playoffs this season. Boston had a late season collapose and didn't miss the playoffs by far.


```{r message=FALSE, warning=FALSE}
## Find the relationship between shots attempted and goals scored for each team ##
ts <- mlshots %>% group_by(Team) %>% 
                  summarize(Shots = n(), 
                            Misses = sum(Event=="MISS"), 
                            Goals = sum(Res), 
                            A = (Shots-Misses)/Shots, 
                            GP = Goals/(Shots-Misses))

ggplot(ts, aes(Shots,Goals,label=Team)) + geom_point() + geom_text(nudge_y = -1.5, size = 3) + ggtitle("Shot Attempts vs Goals by Team")

```

Looking at some of the other metrics, distance appears to have a large effect on goal scoring. The series at the top indicate shooting accuracy, the two lines below are probabilities of scoring. Interestingly, there appears to be a slight increase in shot accuracy around the 30~40ft mark. This is likely the result of an open lane to the net just above the face-off circle.

```{r message=FALSE, warning=FALSE}
## Find the relationship between shots and distances during power play and full strength ##
distg <- mlshots %>% group_by(Dist, PP) %>% 
                     summarize(Shots = n(), 
                               Misses = sum(Event=="MISS"), 
                               Goals = sum(Res), 
                               A = (Shots-Misses)/Shots, 
                               GP = Goals/(Shots-Misses)) %>% 
                      filter(Goals > 10)

ggplot(distg %>% filter(PP != "SH"), aes(Dist)) + 
  geom_point(aes(y=GP, color = PP)) + 
  geom_point(aes(y=A,)) + 
  geom_smooth(aes(y=GP, color = PP), span = 0.9) + 
  geom_smooth(aes(y=A), span = 0.9) +
  ggtitle("Shot Accuracy vs. Probability of Scoring by Shooting Distance")

```

We can also look at how goals are distributed amongst the players. Most of the data fall into a normal distribution. However, there are certain tipping points that separate the elite players from the "average" players (as well as under-performing players)

```{r message=FALSE, warning=FALSE}
## Individual Player Shooting Data ##
psa <- mlshots %>% group_by(Shooter, Pos2, Team) %>% 
                   summarize(Shots = n(), 
                   Misses = sum(Event=="MISS"), 
                   Goals = sum(Res), 
                   A = (Shots-Misses)/Shots, 
                   GP = Goals/(Shots-Misses))

hist(log(psa$GP,10), breaks = 20)
qqnorm(psa$GP)

### We set the minimum probability of scoring as 1%, this will be used later in the Advanced Model
psa$GP[is.na(psa$GP)] <- 0.01
s_adj <- sd(psa$GP)
```

Visualizing how forwards and defense shoot and score, we can see some defensemen play an offensive style of hockey.It's also interesting to note different players' playing style. Riskier shots (those aimed at the corners and bar-down) have a higher probability of scoring, but also higher probability of missing the net altogether. Similarly, some players have higher shooting accuracy, but those shots are more likely to be stopped by the goaltender, hence have a lower scoring probability.

It will be very informative if we can apply this analysis over the course of, say, 10 years to see the evolution of a player.


```{r message=FALSE, warning=FALSE}
ggplot(psa %>% filter(Goals > 1), aes(A,GP, color = Pos2, size = Goals)) + 
  geom_point(alpha=0.5) + 
  ggtitle("Forward/Defense: Shooting Accuracy vs. Probability of Scoring") +
  xlab("% of shots on net") + ylab("Probability of Scoring")

ggplot(psa %>% filter(Goals > 20), aes(A,GP, size = Goals, label = Shooter)) + 
  geom_point(alpha=0.5, aes(color = Goals)) +
  geom_text(aes(color=Goals), alpha = 0.8, nudge_y = -0.003) +
  scale_colour_gradient(low="grey50", high="deepskyblue4") +
  ggtitle("Top Scorers: Shooting Accuracy vs. Probability of Scoring") +
  xlab("% of shots on net") + ylab("%Probability of Scoring") 
```


#Assessing Goaltenders

To evaluate goaltender performances, the idea is to calculate the probability of each shot of scoring and adjusting for the paramters layed out in the introduction using multivariate regression. To make the model more advanced, we add in the "Player Factor" to take into consideration that elite players have better shooting skills.

A way to assess the "fit" of this model will be to compare how many goals a player scored versus how many goals the player is *expected* to score according to the model. We use the RMSE value as an indicator. Once the coefficients are set, we will then look at each goalie and the shots he faced, and calculate the number of goals the goalie was expected to let in, as suggested by the model.

We can start with the baseline/naive case, assuming every shot has equal probability of scoring.

```{r message=FALSE, warning=FALSE}
library(caret)
library(broom)

baseline <- mlshots %>% group_by(Shooter) %>% 
                        summarize(Shots = n(), 
                                  EG = sum(mean(psa$GP*Shots)),
                                  GA = sum(Res),
                                  Diff = GA - EG)
str(baseline)
### RMSE Value: Baseline ###
sqrt(sum(baseline$Diff**2))
hist(baseline$Diff)

```

Now we improve the model by adjusting for various effects. The intermediate model takes into consideration shots and team effects. Shots are adjusted for type, distance, and source. Team effects are adjusted for their playing style. This means that goalies on defense-oriented teams and teams with poor defense are are punished differently for letting each goal.


In the advanced model, player factors are taken into consideration. Intuitively, this system of evaluation awards goaltenders when they make a save against an elite shooters. The "Player Factor" is also capped at one standard deviation of the overall NHL shooting average. This ensures that goalies are not punished disproportionally for allowing a bad goal against a below-average player. 

Of the three models, the advanced model has the lowest RMSE value. This will be the model we use to evaluate goalies. 

```{r message=FALSE, warning=FALSE}
### Adjusting for Distance, Shot Type, Position, Power Play
model <- lm(Res ~ Dist*ShotType*Pos2 + PP + Team + Opp,  data = mlshots)

res1 <- augment(model, mlshots)
res1p <- res1 %>% group_by(Shooter) %>% 
               summarize(Shots = n(), 
                         EG = sum(.fitted),
                         GA = sum(Res),
                         Diff = GA - EG)
head(tidy(model),10) %>% kable(pad = 0)

### RMSE Value: Basic Adjustments ###
sqrt(sum(res1p$Diff**2))

PFactor <- res1p %>% mutate(PF = Diff/Shots) %>% select(Shooter, PF)
PFactor <- PFactor %>% mutate(PF_adj = ifelse(PF > s_adj | PF < - s_adj, PF/abs(PF)*s_adj, PF)) %>% select(Shooter, PF_adj)

res1 <- left_join(res1, PFactor)
res1f <- res1 %>% group_by(Shooter) %>% 
                 summarize(Shots = n(), 
                 EG = sum(.fitted + PF_adj),
                 GA = sum(Res),
                 Diff = GA - EG)

### RMSE Value: Advanced Adjustments ###
sqrt(sum(res1f$Diff**2))

```

We can rearrange the results table from above to calculate vital statistics for goaltenders. Shots is the number of shots the goalie faced in regular season, EG is the expected goals the goalie would allow according the model, GA is the actual goals allowed by the goalie, and Diff is the percentage difference between expectation and actual. A negative Diff indicates the goaltender allowed fewer goals than expected - which ranks the goalie higher.

```{r message=FALSE, warning=FALSE}
## Getting goalie rank list ###
res1g <- res1 %>% group_by(Goalie) %>%
                 summarize(Shots = n(), EG = sum(.fitted), GA = sum(Res), Diff = ((GA-EG)/(EG))) %>%
                 filter(Shots > 100) %>%
                 arrange(Diff)

res1g %>% kable(format = "html", pad = 5)

```


A few players near the top of the list may be hidden gems and will require further attention from the scouts. Players such as CALVIN PICKARD and JOONAS KORPISALO who played on very poor teams this season (Colorado Avalanche and Columbus Blue Jackets respectively) do not appear on the first page of a hockey statistics table.

# Further Analysis
Another perspective to analyzing goaltender performance is in looking at specific shooter/goaltender match up. To limit the size of the matrix, we'll use the "Elite" shooter and goalie. These parameters can be set to analyze different tiers of players and goalies. The result of this analysis has implications in assembling specific lines against certain goalies, or in shoot-outs.

Unsurprisingly, "EMPTY NET" is the worst goalie - most players have a high probability of scoring on an empty net.

```{r fig.width = 10, fig.height=15, message=FALSE, warning=FALSE}
psa_elite <- psa %>% filter(Goals > 20) %>% .$Shooter
g_elite <- res1 %>% group_by(Goalie) %>% 
                    summarize(Shots = n()) %>% filter(Shots > 1000 | Goalie == "EMPTY") %>% .$Goalie

TM <- mlshots %>% group_by(Shooter, Goalie) %>%  
                    filter(Shooter %in% psa_elite & Goalie %in% g_elite) %>%
                    summarize(GP = sum(Res)/n())

TM <- TM %>% spread(key = Goalie, value = GP)
TM <- as.matrix(TM)
rownames(TM) <- TM[,1]
TM <- TM[,-1]
TM[is.na(TM)] <- 0.20 
### Since not every player has taken shots agains every goalie, we have to set a default probability of scoring

class(TM) <- "numeric" 

coloring <- colorRampPalette(c("blue", "white","yellow","red"))(n = 100)
heatmap(TM, col=coloring,main="Shooter-Goalie Match-UP Matrix")

```

#Unsupervised Machine Learning
PCA analysis also singles out EMPTY in the ranks of goalies.Although the first two principal components do only explain about 20% of the variance - which does not help much.

```{r message=FALSE, warning=FALSE}
library(ggrepel)

## With EMPTY
pca <- prcomp(TM)
summary(pca)
Goalie <- colnames(TM)
pc <- data.frame(pca$rotation, name = Goalie)

ggplot(pc, aes(PC1, PC2)) + geom_point() + geom_text_repel(aes(label=name), size = 3)

## Without EMPTY
TM2 <- TM[,-14]
pca2 <- prcomp(TM2)
summary(pca2)
Goalie <- colnames(TM2)
pc2 <- data.frame(pca2$rotation, name = Goalie)

ggplot(pc2, aes(PC1, PC2)) + geom_point() + geom_text_repel(aes(label=name), size = 3)
```

#Applications of Goalie Analytics on the NHL 2015-2016 Playoffs

In the first round of the NHL playoffs, several teams struggled with deciding which goalie should they play. Pittsburgh Penguins (PIT), Philadelphia Flyers (PHI), Dallas Stars (DAL). Below is the list of goaltenders.

PIT: JEFF ZATKOFF (Game 1W, Game 2L), MATTHEW MURRAY (Game 3W, Game 4W, Game 5W)
PHI: STEVE MASON (Game 1L, Game 2L, Game 3L), MICHAEL NEUVIRTH (Game 4W, Game 5W, Game 6L)
DAL: KARI LEHTONEN (Game 1W, Game 2W, Game 3L, Game 6W), ANTTI NIEMI (Game 4W, Game 5L), 

Hockey analysts typically favour goaltenders with more "experience" to play in the playoffs. This has been the case in the three teams above. Both PIT and PHI started the series with the goalie who's ranked lower on the list. It took a big loss for the team to switch their goalie. PHI, for example, played STEVE MASON in the first three games, resulting in three losses before switching to MICHAEL NEUVIRTH, who should be playing from the beginning according to our analytics. He won two out of the next three games - but it was too little too late for the Philadelphia Flyers.

The Dallas Stars have two goalies who are very similar in experience and ranked in the lower half according to analytics. They have both struggled.

#Pitfalls and Future Prospects

When it comes to goaltender performance, consistency is a major factor. As elite atheletes in the NHL, all goaltenders are capable of putting up great statistics, the difference is in who is able to do so on a consistent basis. This analytics project is weak in that it only considers the statistics for a single season. Therefore it discounts the value of analytics in helping teams trade or target a goalie to acquire.

...and that is why this model has tremendous value in the world of fantasy sports - a once popular office hobby that turned into a billion dollar industry - where rosters are adjusted weekly to take advantage of players' streaks. The work is far from complete, future analysis will include line-combination and team match-ups with Monte Carlo simulation.

We will soon be launching a for-profit website dedicated to fantasy sports analytics.














..............All.Rights.Reserved................




